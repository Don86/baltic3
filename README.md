# baltic3

`baltic`(*Backronymed Adaptable Lightweight Tree Import Code*) is a phylogenetic tree visualization library. Originally developed by Dr. Gytis Dudas, a postdoc at Trevor Bedford's lab, it wraps `matplotlib` with its own proprietary `tree` object. The original Python2 version is available over at the [Bedford Lab](https://github.com/blab/baltic). That `readme`'s worth a read to explain how the class structures are set up.

* `baltic` isn't as good as `Biopython` at tree manipulation...
* But it's far superior at visualization for presentation and publication-standard figures.
* `baltic` trades off ease-of-use with flexibility. I'd call it difficult to learn, but easy to master.

The modules are:

* `baltic3` - contains the `tree`, `node` and `leaf` class definitions, and class methods.
* `baltic3_utils` - function library that contains public methods.
* `experimental` - function library that contains new methods which are still under development.

# Installation

There's no installation per se; simply `git clone` or download this repo to a known location (say, your desktop), and, in `Jupyter`, point your `PYTHONPATH` to it. That is, in `Jupyter`:

```
import sys
sys.path.append("path/to/baltic3")

# import the modules of this package
# Only 2 modules
import baltic3 as bt
import baltic3_utils as btu
```

# Tutorials

`baltic` is meant to be executed in Jupyter, since the final output is probably a pdf of your final image. There's a series of example notebooks in the `/tutorials` directory of this repo. In recommended order:

* [Tutorial 1](https://github.com/Don86/baltic3/blob/master/tutorials-and-examples/Tutorial1.md) - Required input format for `baltic`.
* [Tutorial 2](https://github.com/Don86/baltic3/blob/master/tutorials-and-examples/Tutorial2.md) - About the `baltic` tree object.
* [Gallery](https://github.com/Don86/baltic3/blob/master/tutorials-and-examples/Gallery.ipynb) - Gallery of examples, though so far there's only 1 example in there.

The rest of the examples are more complex examples of different visualisations.

### Is this easy to learn?

(This is the most frequently asked question I get)

Short answer: no.

Long answer: I'm not sure. In my use cases, I set up baltic to work in `Jupyter` notebooks like the front-end trifecta of HTML/CSS/JS (or: rendering with `matplotlib`/parameter or attribute value definitions/programmatic functionality, respectively).  If that last sentence was gibberish to you, this will have a bit of a learning curve. Otherwise, if you're already familiar with that sort of paradigm, it might be that much easier. 

If you're new to Python, this is not a good starting point.

# Known Issues/To Do/Dev Notes

* Leaf placement for non-BEAST chronograms (i.e. branch lengths are proportionate to time), such as those produced by `treetime` or `lsd`, is occasionally inaccurate. I'm not sure why, and I'm not even sure if I fixed these or not.  
* There is an issue from the way that `absoluteTime` is implemented. It only makes sense if the input tree is a chronogram, where the `absoluteTime` attribute is populated from iteratively computing branch lengths, particularly to populate the `absoluteTimes` of internal nodes. This initially made sense because `baltic` was originally written to process BEAST trees. When expanded to include other kinds of trees (like ML trees), this behaviour no longer makes sense. As such, if given, say, a tree generated by `RAxML`, which just happens to have tip dates in the tipnames (and mistakenly parsed as a dated tree in the `austechia_read_tree()` function from user error), the `absoluteTime` parameter will return a nonsensical number. I believe that this odd behaviour is what's playing havoc with the known issue above.
* *Maximum a posteriori* (MAP) chronograms with branches that go backwards in time (whereby descendant tips seem to chronologically occur before their ancestral nodes) are untested; but they logically should work.
* I have not explicitly catered for the two different `newick` representations of multifurcations, nor have I seen any code anywhere that does this. But it appears to be working fine (in the sense that all multifurcating trees so far have turned out as expected upon visual inspection - but this deserves a unit test nevertheless).
* As always, robustify input formats.
* Find a way to allocate unique internal node identifiers of some kind, in either of the 3 tree-traversal methods.
* Perform tip-to-mrca-to-tip computations. Problem is: can't identify the MRCA of two given tips, because the nodes don't have a unique identifier. These computations are currently done in `Bio.Phylo`; but calling to an external library seems inelegant.

### Porting over to Biopython

This would be tremendously useful primarily because Biopython is faster with I/O, and already accepts different kinds of inputs, and already has the associated `Bio.Phylo` tree classes and related functions. However, this would warrant a massive code overhaul; that is, translating a `Bio.Phylo()` object to a `baltic` object.

* Only one missing function: allocating (x, y) coords to each node.
* `Biopython` loads trees faster. `baltic` can take several minutes for a large tree. A rule of thumb is ~1 minute per thousand tips.
* `baltic` is too fussy about the tree input format (has to be nexus format).
* `baltic` can't handle asterisks, because it parses the newick string with regex, where '\*' is a wildcard character.
