# baltic3

This is a phylogenetic tree visualization library. Originally developed by Gytis Dudas, it wraps `matplotlib`

The Python 3 version of Baltic: the *Backronymed Adaptable Lightweight Tree Import Code*. The original Python2 version is available over at the [Bedford Lab](https://github.com/blab/baltic). That `readme`'s worth a read to explain how the class structures are set up. Gytis' original version is being migrated over to Python3, but I'm not sure if it's still under active development.

The main libraries are:

* `baltic3` - contains the `tree`, `node` and `leaf` class definitions, and class methods.
* `baltic3_utils` - function library that contains public methods.
* `experimental` - function library that contains new methods which are still under development.

# Installation

There's no installation per se; simply `git clone` or download this repo to a known location (say, your desktop), and, in `Jupyter`, point your `PYTHONPATH` to it. That is, in `Jupyter`:

```
import sys
sys.path.append("path/to/baltic3")

# import the modules of this package
# Only 2 modules
import baltic3 as bt
import baltic3_utils as btu
```

# Tutorials

`baltic` is meant to be executed in Jupyter, since the final output is probably a pdf of your final image. There's a series of tutorial notebooks in the `/tutorials` directory, enumerated in the recommended order.

### Is this easy to learn?

(This is the most frequently asked question I get)

Short answer: no.

Long answer: I'm not sure. In my use cases, I set up baltic to work (somewhat) in `Jupyter` notebooks like the front-end trifecta of HTML/CSS/JS (or: rendering with `matplotlib`/parameter or attribute value definitions/programmatic functionality, respectively).  If you're already familiar with that sort of paradigm, it might be that much easier. Otherwise, if that second sentence was gibberish to you, this will have a bit of a learning curve.

If you're new to Python, this is not a good starting point.

# Known Issues

* Leaf placement for non-BEAST dated trees, such as those produced by `treetime` or `lsd`, is occasionally inaccurate. I'm not sure why, and I'm not even sure if I fixed these or not.  
* There is an issue from the way that `absoluteTime` is implemented. It only makes sense if the input tree is a chronogram (i.e. branch lengths are proportionate to time), where the `absoluteTime` attribute is populated from iteratively computing branch lengths, particularly to populate the `absoluteTimes` of internal nodes. This initially made sense because `baltic` was originally written to process BEAST trees. When expanded to include other kinds of trees (like ML trees), this behaviour no longer makes sense. As such, if given, say, a tree generated by `RAxML`, which just happens to have tip dates in the tipnames (and mistakenly parsed as a dated tree in the `austechia_read_tree()` function from user error), the `absoluteTime` parameter will return a nonsensical number. I believe that this odd behaviour is what's playing havoc with the known issue above.
* MAP trees with branches that go backwards in time (whereby descendant tips seem to chronologically occur before their ancestral nodes) are untested; but they logically should work.

# To Do/Dev Notes

 - As always, robustify input formats.
 - Find a way to allocate unique internal node identifiers of some kind, in either of the 3 tree-traversal methods.
 - Perform tip-to-mrca-to-tip computations. Problem is: can't identify the MRCA of two given tips, because the nodes don't have a unique identifier. These computations are currently done in `Bio.Phylo`; but calling to an external library seems inelegant.

### Porting over to Biopython

This would be tremendously useful primarily because Biopython is faster with I/O, and already accepts different kinds of inputs, and already has the associated `Bio.Phylo` tree classes and related functions. However, this would warrant a massive code overhaul; that is, translating a `Bio.Phylo()` object to a `baltic` object.

* Only one missing function: allocating (x, y) coords to each node.
* `Biopython` loads trees faster. `baltic` can take several minutes for a large tree. A rule of thumb is 1 minute per thousand tips (on a Macbook Pro 2015).
* `baltic` is too fussy about the tree input format (has to be nexus format).
* `baltic` can't handle asterisks, because it parses the newick string with regex, where '\*' is a wildcard character.

# Acknowledgements

* [Dr. Gytis Dudas](https://github.com/evogytis) - Wrote original code base in Python2
* Prof. Vijay Dhanasekaran - funded and supported development
